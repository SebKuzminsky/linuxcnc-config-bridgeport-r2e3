
#
# This HAL file hooks up the control panel.
#
#
# Uses:
#     encoder.03 (jogwheel)
#     ilowpass.0 (to smooth the jogwheel)
#     tristate_float 0-2 (to select the jog increment)
#     gpio 28 & 29 (varispeed spindle faster/slower switch input)
#
# 
# There control panel has these features:
# 
#     * a latching E-stop button
#     * 6 momentary push-buttons that do continuous jogs on all three axes
#     * a momentary push-button that turns the spindle on/off
#     * a momentary toggle switch that spins the stepper that controls the varispeed
#     * a rotary switch that selects which axis to jog: X, Y, or Z
#     * a rotary switch that selects the jog increment: 0.0001, 0.001, or 0.010
#     * a jog wheel
# 
#
#     The axis selection switch makes the selected axis.*.jog-enable True
#     and makes the others False.  The jog increment switch addresses a mux
#     to output the desired jog increment to all the axis.*.jog-scale pins.
#     The jogwheel stays connected just like now.
#
# The jog increment selector looks to hal like a bunch of bits, exactly one
# of which is True at a time, and each bit corresponds to a different value
# to feed to axis.*.jog-scale.  Heh, maybe use a mux16, and use each
# different button as a different address line, and just skip the unused
# addresses where multiple address lines are True at the same time.
#     
# Or maybe use tristate_float?  One tristate_float per jog speed, all
# hooked to a net called jog-increment, each enabled by a different bit
# from the jog speed rotary switch.
#




# estop
# this bit is an external estop button
# wire #46 in the bp wiring diagram
net ext-estop <= hm2_[HOSTMOT2](BOARD).0.gpio.024.in_not




#
# continuous jog
# FIXME: just Z for now, need another 7i37...
#

net continuous-jog-z-plus  <= hm2_[HOSTMOT2](BOARD).0.gpio.037.in_not
net continuous-jog-z-plus  => halui.jog.2.plus

net continuous-jog-z-minus <= hm2_[HOSTMOT2](BOARD).0.gpio.038.in_not
net continuous-jog-z-minus => halui.jog.2.minus




#
# hook up the spindle speed switch to the varispeed nets
# gpio 28 & 29 are the (on)-off-(on) momentary on the faceplace
#

net varispeed-slower <= hm2_[HOSTMOT2](BOARD).0.gpio.028.in_not
net varispeed-faster <= hm2_[HOSTMOT2](BOARD).0.gpio.029.in_not




#
# spindle on/off
#
# FIXME: inhibit varispeed control while the spindle-on-off-button is held
#
# halui.spindle.is-on is true if the spindle is spinning
#
# rising edge on halui.spindle.forward makes it go clockwise
# rising edge on halui.spindle.reverse makes it go counter-clockwise
# rising edge on halui.spindle.stop stops the spindle
#

setp oneshot.0.width 0.010
net spindle-button <= hm2_[HOSTMOT2](BOARD).0.gpio.036.in_not
net spindle-button => oneshot.0.in
net spindle-button-pushed <= oneshot.0.out

net halui-spindle-is-on <= halui.spindle.is-on

net halui-spindle-is-on => not.0.in
net spindle-is-off <= not.0.out

# spindle-button AND is-on => stop
net spindle-button-pushed => and2.0.in0
net halui-spindle-is-on => and2.0.in1
net turn-spindle-off <= and2.0.out
net turn-spindle-off => halui.spindle.stop

# spindle-button AND (NOT is-on)
net spindle-button-pushed => and2.1.in0
net spindle-is-off => and2.1.in1
net spindle-button-while-off <= and2.1.out

# (spindle-button AND (NOT is-on)) and varispeed-faster => forward
net spindle-button-while-off => and2.2.in0
net varispeed-faster => and2.2.in1
net spindle-cw <= and2.2.out
net spindle-cw => halui.spindle.forward

# (spindle-button AND (NOT is-on)) and varispeed-slower => reverse
net spindle-button-while-off => and2.3.in0
net varispeed-slower => and2.3.in1
net spindle-ccw <= and2.3.out
net spindle-ccw => halui.spindle.reverse

addf oneshot.0 servo-thread
addf not.0 servo-thread
addf and2.0 servo-thread
addf and2.1 servo-thread
addf and2.2 servo-thread
addf and2.3 servo-thread




#
# hook up the jog-axis selector switch to the axis jog-enable pins
#

net x-jog-enable hm2_[HOSTMOT2](BOARD).0.gpio.030.in_not => axis.0.jog-enable
net y-jog-enable hm2_[HOSTMOT2](BOARD).0.gpio.031.in_not => axis.1.jog-enable
net z-jog-enable hm2_[HOSTMOT2](BOARD).0.gpio.032.in_not => axis.2.jog-enable




#
# jog increment selector
#

setp tristate-float.0.in 0.0000001
setp tristate-float.1.in 0.000001
setp tristate-float.2.in 0.000010

net select-jog-inc-0.0001 hm2_[HOSTMOT2](BOARD).0.gpio.033.in_not => tristate-float.0.enable
net select-jog-inc-0.001  hm2_[HOSTMOT2](BOARD).0.gpio.034.in_not => tristate-float.1.enable
net select-jog-inc-0.010  hm2_[HOSTMOT2](BOARD).0.gpio.035.in_not => tristate-float.2.enable

net jog-scale <= tristate-float.0.out
net jog-scale <= tristate-float.1.out
net jog-scale <= tristate-float.2.out

net jog-scale => axis.0.jog-scale
net jog-scale => axis.1.jog-scale
net jog-scale => axis.2.jog-scale

addf tristate-float.0 servo-thread
addf tristate-float.1 servo-thread
addf tristate-float.2 servo-thread




#
# My jog wheel has 50 clicks per revolution, and 4 quadrature edges per
# click.
# 
# Low-pass filter the jogwheel, and scale it so one click is 1000 counts
# coming out of the ilowpass.
#
# Then connect it to the jog input on all the axes.
#

setp ilowpass.0.gain .02
setp ilowpass.0.scale 250

net jogcounts_raw <= hm2_5i20.0.encoder.03.count
net jogcounts_raw => ilowpass.0.in

net jogcounts_cooked  <= ilowpass.0.out
net jogcounts_cooked  => axis.0.jog-counts
net jogcounts_cooked  => axis.1.jog-counts
net jogcounts_cooked  => axis.2.jog-counts

addf ilowpass.0 servo-thread

